1. 테스트 케이스 수 `T` (1 ≤ `T` ≤ 100)이 주어집니다.
2. 매 테스트 케이스마다 맵의 가로 크기 `n` 과 세로 크기 `m` 이 주어집니다. (2 ≤ `h`, `w` ≤ 100)이 주어집니다.
3. `.` 이 길, `*` 이 벽, `$` 이 훔쳐야할 문서, 알파벳 소문자는 열쇠, 대문자는 문입니다.
4. 마지막 줄에 이미 갖고 있는 열쇠가 소문자 문자열로 주어집니다. 없을 경우 `0` 이 입력됩니다.
5. 각 테스트케이스마다 최대 몇 개의 문서를 훔칠 수 있는지 출력합니다.
6. 처음 탐색 가능 시작위치는 맵의 모든 가장자리입니다.

## 틀린 문제 풀이

1. 열쇠의 보유 여부를 배열의 비트 마스킹으로 처리합니다. 똑같은 비트에서 문서를 몇 개 갖고 있는지에 따라 백트래킹합니다.
2. 이때 `1 << 26` 으로 배열 사이즈를 선언하면 자바의 최대 범위를 초과합니다.
3. 처음시작할 때 갖고 있던 열쇠를 모두 넣습니다. 그 후 각 열쇠를 얻을때마다 해당 탐색의 열쇠 비트값을 갱신합니다.
4. 시작 가능한 모든 위치에서 bfs를 수행해 더이상 갈 수 있는 곳이 없을때까지 수행한 후 가장 많은 문서를 보유한 경로의 문서 값을 출력합니다.

---

- 플래그로 비트마스킹할 경우 26개의 알파벳 모두를 담을 수 없음
- 비트를 값으로 선언하여 비교 시 비교가 제대로 되지 않음
- 훔친 서류의 수를 경로에 저장할 필요가 없음

## 문제 풀이

1. 열쇠를 획득할 때마다 모든 방문 배열을 초기화 하고, 해당 문을 제거합니다.
2. 문서를 획득할 때마다 해당 문서를 맵에서 지우고 최대 문서합을 더합니다.