## 문제 정의

1. 각 테스트 케이스 T( 1 ≤ T ≤ 50) 별로 전화번호 목록이 입력됩니다.
2. 전화번호의 수 N (1 ≤ N ≤ 10000)이 주어지고 다음 열부터 N 개열에 10자리 미만의 전화번호가 주어집니다.
3. 각 전화번호 목록에서 어떤 한 전화번호가 다른 전화번호의 접두어가 되면 안됩니다.
4. 접두어가 되는 경우가 있을 경우엔 NO, 하나도 없는 경우에는 YES 출력합니다.

## 설계

### 비트 비교 풀이

1. 전화번호 목록을 모두 받아 뒤집은 후 int 형 배열에 저장한다.
2. 저장된 배열을 정렬한 후 i = 1 부터 i = N 까지 i - 1과 i 를 비트 &연산하여 i - 1과 같거나, i 와 같으면 break 후 no를 출력한다.
3. 비교 시 i-1 과 i 를 비트 & 연산으로 비교합니다.
4. 모두 검사가 끝났음에도 NO가 아니라면 YES 출력합니다.
- 비트마스킹을 하려면 뒤집어서 int 형으로 저장해야 하는데, 그러면 끝 자리가 0일 경우의 예외를 처리할 수 없으므로 안됩니다.

### 문자열 비교 풀이

1. 전화번호 목록을 모두 받아 공백을 지우고 배열에 저장합니다.
2. 저장된 배열을 정렬한 후 i = 1 부터 i = N 까지 i와 i - 1를 비교합니다. 
3. 비교 시 둘 중 길이가 짧은 문자열의 길이로 두 문자열을 자른 후 서로가 같은지 비교합니다. 같으면 false
4. 모두 검사가 끝났음에도 NO가 아니라면 YES를 출력합니다.

## 코드

```java
N = Integer.parseInt(br.readLine());
arr = new String[N];

for(int i = 0 ; i < N ; i++){
    arr[i] = br.readLine().trim();
}
Arrays.sort(arr);
```

- 공백을 지우고 배열에 담은 후, 사전 순으로 정렬합니다.

```java
for(int i = 1 ; i < N ; i++){
    int len = Math.min(arr[i].length(), arr[i-1].length());
    if(arr[i].substring(0, len).equals(arr[i - 1].substring(0, len)))       return false;
}
return true;
```

- 앞 뒤에 있는 문자열과 서로 비교합니다. 비교할 때 더 짧은 문자열로 길이를 바꿔서 equals로 비교합니다.
- 같은 문자열이 나오면 false를 리턴해 NO를 출력하게 하고 같은 문자열이 없다면 true를 리턴해 YES를 출력하게 합니다.