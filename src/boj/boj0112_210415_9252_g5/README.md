## 문제 정의

1. 두 문자열이 입력됩니다.
2. 가장 긴 증가하는 공통 수열의 길이와 그 수열을 출력합니다.

## 문제 풀이 - 최장 공통 부분 수열

- `LCS` 는 다음과 같은 테이블로 DP를 구성할 수 있습니다

```jsx
|   | # | C | A | P | C | A | K |
|---|---|---|---|---|---|---|---|
| # | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| A | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
| C | 0 | 1 | 1 | 1 | 2 | 2 | 2 |
| A | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
| Y | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
| K | 0 | 1 | 2 | 2 | 2 | 3 | 4 |
| P | 0 | 1 | 2 | 3 | 3 | 3 | 4 |
```

1. 비교하려는 문자가 서로 같을 경우 `i == j`
    1. 이 같은 경우는 최장 공통 부분 문자열에 포함되는 내용입니다.
    2. 그러므로 이전 인덱스까지 최대 공통 부분 문자열의 값을 그대로 가져온 후 현재 값까지 + 1합니다
    - `f(i, j) = f(i - 1, j - 1) + 1`
2. 비교하려는 문자가 서로 다를 경우 `i ≠ j`
    1. 이 경우는 `i` , `j` 는 최장 공통 부분 문자열에 포함되지 않습니다.
    2. **즉 이 값은 고려하지 않아도 되므로 이전까지의 최장 공통 부분 문자열의 크기를 가져옵니다.**
    3. 이 중 비교하려는 문자열의 어느것을 가져와도 되므로 둘 중 큰 것을 가져옵니다
    - `f(i, j) = max(f(i - 1, j), f(i, j - 1))`

### 역 추적하여 문자열 찾기

1. LCS 를 구성하는 문자열을 찾기 위해서는 마지막으로 완성된 `dp` 테이블에서 역추적해서 찾아야합니다.
2. LCS 구성 문자열은 두 문자가 같을 때만 가능하며 이 경우에만 기록합니다.
3. 아닌 경우는 `dp` 배열에서 같은 인덱스를 가진 테이블로 이동하여 계속 검사합니다.

```jsx
private static String findStr(){
	Deque<Character> stk = new ArrayDeque<>();
	int i = len1;
	int j = len2;
	while(i != 0 && j != 0){
		if(in1[i - 1] == in2[j - 1]){
			stk.push(in1[--i]);
			j--;
			continue;
		}
		if(d[i][j] == d[i - 1][j])      i--;
		else if(d[i][j] == d[i][j - 1]) j--;
	}
	StringBuilder sb = new StringBuilder();
	while (!stk.isEmpty())  {
		sb.append(stk.pop());
	}
	return sb.toString();
}
```