## 문제 정의

1. 입력 수의 자리수 N과 지울 수 있는 수 K를 입력으로 받는다
2. N자리의 수를 입력받는다
3. K개의 수를 지워 출력할 수 있는 가장 큰 수를 출력한다.

## 설계

1. 입력받는 수를 br 로 입력받고 char[]에 저장한다. 스택을 정의하고 최대 자리 수 N - K 를 저장한다.
2. 첫 째자리부터 검사하여 스택의 탑과 비교한다. 스택의 탑보다 수가 크다면 최대 팝 회수 K를 초과하지 않는 한 반복한다. 
3. 반복 시 스택을 팝하고 최대 자리수를 하나 더한다.
4. 2의 조건을 통과하고, 최대 자리수를 초과하지 않는다면 스택에 push한다.
5. 가질 수 있는 자리 수를 초과했다면 현재 스택의 탑과 비교하여 더 크다면 스택을 팝하고, 현재 수를 푸시한다.
6. 스택을 다시 스택에 넣었다 빼어(혹은 deque 사용) 처음 입력한 수부터 출력한다.

## 코드

1. 입력 할당 및 정보 저장

```java
arr = br.readLine().toCharArray();

int num;
int count = N - K;

for(int i = 0 ; i < arr.length; i++){
```

- 입력 수 arr, count = 출력 자리수

 2.  pop

```java
while(!dq.isEmpty() && 
			dq.getFirst() < num && K != 0){
    dq.pop();
    K--;
    count++;
}
```

- 스택이 비어있지 않고, 현재 수가 탑보다 크며, 팝 가능 회수를 초과하지 않았을 경우 수행
- 수행시 스택을 팝하고, 팝 가능회수—, 출력 자리수 ++

 3. push

```java
if(count > 0 ) {
    dq.push(num);
    count --;
}else if(!dq.isEmpty() && dq.getFirst() < num){
    dq.pop();
    dq.push(num);
}
```

- 자리수가 남아 있을 경우 바로 push
- 남아 있지 않은 경우 현재 top과 비교해서 크다면 pop하고 push

## 후기

처음에 문제만 읽고 스택으로 구현 후 pop할 수 있는 수만 제한하면 된다고 쉽게 생각했다. 하지만 그럴 경우 pop을 앞자리에서 다하고 뒷자리 검사할 때는 아무런 조건없이 push되어 출력 초과가 발생했다. 그래서 출력 자리수를 변수로 저장하고 그에 맞게 입력을 받았다.