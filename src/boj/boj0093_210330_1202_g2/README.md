## 문제 정의

1. 첫째 줄에 보석의 수 `N` 과 가방의 수 `K` 가 주어집니다 ( 1 ≤ N, K ≤ 300,000)
2. 다음 `N` 개 줄에는 보석의 무게와 가치가 주어집니다
3. 다음 `K` 개 줄에는 가방에 담을 수 있는 무게 가 주어집니다.
4. 모든 가방엔 최대 하나의 보석만 넣을 수 있을 때 훔칠 수 있는 최대 가치를 출력합니다.

## 문제 풀이

1. 보석을 가치 내림차순으로 정렬하고, 가방은 오름차순으로 정렬합니다.
2. 이진 탐색으로 보석의 무게에 해당하는 가방을 찾고, 없다면 그것보다 크면서 가장 가까운 가방을 찾습니다.
    1. 이때 선형적으로 가방을 찾는다면 시간초과가 발생하므로 가방을 찾을 떄 다음에 넣어야하는 가방을 유니온 파인드로 찾습니다.
    2. 찾았다면 그 가방에 다음에 넣어야하는 가방의 값을 ++해서 처리합니다.
    3. 정렬된 가방 배열이므로 다음에 나오는 값은 무조건 현재 가방보다 큽니다.

## 후기

이진탐색을 써서 나름 초기화를 했다고 생각했지만 비어있는 가방을 찾는 과정이 선형적이어서 시간초과가 났습니다 (O(N^2))

그래서 분리집합의 부모를 찾는 `find` 와 `path compression` 을 통해서 다음에 넣을 가방을 찾게 구현했습니다. 그리고 가방의 무게들이 같을 수 있으므로 그냥 이진탐색하는 것 말고 `lower_bound` 를 구현해서 찾으려는 무게보다 높은 첫번째 가방에 넣도록 구현합니다.

- `lowerBound` 코드

```java
private static int binSearch(int key){
		int low = 0;
		int high = K - 1;

		while (low <= high){
			int mid = (low + high) >> 1;
			int midVal = bags[mid];
			if(midVal < key)        low = mid + 1;
//			else if(midVal == key)  return mid;
			//같으면 high가 줄어드니까 -> 로우는 안줄어들 -> lower_bound 역할
			else                    high = mid - 1;
		}
		return low;
}
```