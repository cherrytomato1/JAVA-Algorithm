## 문제 정의

1. 시작지점 N ( 0 ≤ N ≤ 100,000)부터 목표지점 K ( 0 ≤ K ≤ 100,000)까지 이동하는 방법의 최소시간을 구합니다.
2. 걷는다면 1초 후에 한 칸 이동합니다. 순간이동하면 시간은 지나지 않으며 2*현재 위치로 이동하게 됩니다.

## 문제 풀이

1. 각 좌표는 편향이진트리로 볼 수 있습니다. N으로부터 K로 이동하는 최단경로이동을 BFS로 구현합니다. 
2. 단, 순간이동은 소모시간이 0이므로 탐색 중 가장 빨리 도착한 경로가 가장 적은 시간을 소모하는 것은 아니므로 최초 도착 경로가 정답이 아닐 수 있습니다. 따라서 모든 경로에 대하여 탐색합니다.
3. N의 위치부터 탐색을 시작하며 순간이동, 앞으로 걷기, 뒤로 걷기 경로를 탐색합니다.
4. 각 정점에 대한 중복방문을 방지하기 위해 해당 좌표에 도착하기까지 걸린 시간을 배열에 기록하여 가지치기 합니다.
5. 현재 위치가 K를 초과했을 때 걸린 시간을 비교하여 저장합니다.

## 코드

```java
if(pos >= K){
    cnt += pos - K;
    times = times < cnt ? times : cnt;
    continue;
}
```

- `pos` 가 `K` 를 초과했을 때는 뒤로 걷는 경로밖에 남지 않으므로 `K` 와 `pos` 의 거리 차이만큼 이동 회수를 추가해줍니다.

 

```java
if(cnt >= arr[pos] || cnt >= times)    continue;
arr[pos] = cnt;
```

- 탐색중인 경로가 정점에 도달했을 때 정점에 도달하는 데까지 걸린 최소 시간 이상이거나, 도착 최소시간을 초과했다면 더이상 탐색하지 않습니다. 최소 시간이라면 정점의 도착 최소 시간을 갱신합니다.

```java
if(pos != 0) {
    dq.offer(new Node(pos << 1, cnt));
    dq.offer(new Node(pos - 1, cnt + 1));
}
dq.offer(new Node(pos + 1, cnt + 1));
```

- 뒤로 걷기와 순간이동은 현재 좌표가 `0`일 때 할 수 없으므로 예외처리합니다.

## 후기

처음에는 깊이 우선 탐색과 백트래킹으로 해결하려했으나 시간초과를 여러번 만나고 곰곰히 생각해봤을 때 결국 최단경로를 찾는 문제인 것을 알았습니다. 그 이후 bfs로 탐색을 하며 각각의 좌표에 대한 이동 거리로 가지치기를 해주면 되겠다는 생각으로 문제를 해결했습니다.