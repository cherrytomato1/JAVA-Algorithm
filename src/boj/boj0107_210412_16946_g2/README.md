## 문제 정의

1. `N` * `M` 행렬로 표현되는 맵에 `0` 은 길, `1` 은 벽으로 주어집니다 ( 1≤ N, M ≤ 1_000)
2. 인접한 4방향으로만 움직일 수 있다고 했을 때, 각 벽을 부쉈을 때 이동 가능한 범위를 해당 벽 대신 10으로 나눈 값으로 출력합니다.

## 문제 풀이 1

1. 먼저 새 배열을 복사하여 모든 길에 대하여 `bfs` 를 수행하여 모든 `0` 이 갈 수 있는 값을 구해놓습니다.
    1. 각 `0` 에 대하여 방문체크하며, `bfs` 가 수행된 수 만큼 방문체크된 `0` 의 자리에 넣어 놓습니다.
2. ~~각 `1` 에 대하여 주변 4방향의 `0` 이 대체된 값 + 1을 넣습니다 (% 10)~~
    1. `0` 이 대체된 값을 넣을 때 각 그룹별로 묶어준 `0` 의 값을 리스트에서 꺼내 넣습니다.
- 각 1에 대해서 넣을 떄 뭔가 시간 초과를 유발할 로직이 있었던 것 같습니다. 다른 풀이를 보니 이와 같은 방식으로도 해결했습니다.
- 모든 좌표의 `0` 을 다 초기화 하려니 시간복잡도가 폭발했습니다. 그래서 플래그 해준 값을 `1` 에서 검사할때 매칭만 하니 통과!!!~!!

## 문제 풀이 2

1. 위의 1번과 같이 수행합니다.
2. 이 때 벽을 만날때마다 더해줘야하는 벽 리스트를 넘깁니다. 넘겨서 해당 벽에 대해서 더하기를 수행합니다.

## 후기

일단 시간 복잡도가 매우 빡빡한 문제였습니다. 그래서 최대한 시간복잡도를 줄이려는 노력을 많이 했던 것 같습니다.

먼저 배열 생성 및 초기화는 2중 배열일 때 `N * M` 의 동일한 시간복잡도를 갖게된다는 사실을 알았습니다. 또한 반복문의 depth 를 유심히 봐야한다는 사실도 많이 배웠습ㄴ디ㅏ. 좋은 문제 풀이시간을 가진 것 같아 기쁩니다.